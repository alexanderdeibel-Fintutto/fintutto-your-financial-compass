import { useState, useCallback, useEffect } from 'react';

export type DunningLevel = 0 | 1 | 2 | 3;
export type DunningStatus = 'draft' | 'sent' | 'paid' | 'cancelled';

export interface DunningSettings {
  level1DaysOverdue: number;
  level2DaysOverdue: number;
  level3DaysOverdue: number;
  level1Fee: number;
  level2Fee: number;
  level3Fee: number;
  level1InterestRate: number; // Annual interest rate
  level2InterestRate: number;
  level3InterestRate: number;
  paymentDeadlineDays: number;
  autoGenerateDunnings: boolean;
  emailNotifications: boolean;
  companyName: string;
  companyAddress: string;
  bankDetails: string;
}

export interface DunningNotice {
  id: string;
  openItemId: string;
  invoiceNumber: string;
  contactId?: string;
  contactName: string;
  contactAddress: string;
  level: DunningLevel;
  status: DunningStatus;
  originalAmount: number;
  remainingAmount: number;
  dunningFee: number;
  interestAmount: number;
  totalAmount: number;
  dueDate: string;
  paymentDeadline: string;
  sentDate?: string;
  sentVia?: 'email' | 'mail' | 'fax';
  pdfUrl?: string;
  notes?: string;
  createdAt: string;
  updatedAt: string;
}

export interface DunningTemplate {
  level: DunningLevel;
  subject: string;
  salutation: string;
  introText: string;
  mainText: string;
  closingText: string;
  signature: string;
}

const STORAGE_KEY = 'fintutto_dunning';

const DEFAULT_SETTINGS: DunningSettings = {
  level1DaysOverdue: 14,
  level2DaysOverdue: 28,
  level3DaysOverdue: 42,
  level1Fee: 0,
  level2Fee: 5,
  level3Fee: 10,
  level1InterestRate: 0,
  level2InterestRate: 5,
  level3InterestRate: 9.12, // German legal default interest rate
  paymentDeadlineDays: 10,
  autoGenerateDunnings: false,
  emailNotifications: true,
  companyName: 'Ihre Firma GmbH',
  companyAddress: 'Musterstraße 1, 12345 Musterstadt',
  bankDetails: 'IBAN: DE89 3704 0044 0532 0130 00, BIC: COBADEFFXXX',
};

const DEFAULT_TEMPLATES: DunningTemplate[] = [
  {
    level: 1,
    subject: 'Zahlungserinnerung - Rechnung {invoiceNumber}',
    salutation: 'Sehr geehrte Damen und Herren,',
    introText: 'bei der Überprüfung unserer Buchhaltung ist uns aufgefallen, dass die nachstehend aufgeführte Rechnung noch nicht beglichen wurde.',
    mainText: 'Wir möchten Sie freundlich an den offenen Betrag erinnern und bitten Sie, die Zahlung bis zum {paymentDeadline} vorzunehmen.',
    closingText: 'Sollte sich Ihre Zahlung mit diesem Schreiben überschneiden, betrachten Sie diese Erinnerung bitte als gegenstandslos.',
    signature: 'Mit freundlichen Grüßen',
  },
  {
    level: 2,
    subject: '1. Mahnung - Rechnung {invoiceNumber}',
    salutation: 'Sehr geehrte Damen und Herren,',
    introText: 'trotz unserer Zahlungserinnerung vom {lastDunningDate} konnten wir leider noch keinen Zahlungseingang zu der unten aufgeführten Rechnung feststellen.',
    mainText: 'Wir bitten Sie daher nochmals, den offenen Betrag zuzüglich der angefallenen Mahngebühren bis zum {paymentDeadline} auf unser Konto zu überweisen.',
    closingText: 'Sollten Sie Fragen zu dieser Rechnung haben oder eine Ratenzahlung vereinbaren wollen, setzen Sie sich bitte umgehend mit uns in Verbindung.',
    signature: 'Mit freundlichen Grüßen',
  },
  {
    level: 3,
    subject: '2. Mahnung (letzte Mahnung) - Rechnung {invoiceNumber}',
    salutation: 'Sehr geehrte Damen und Herren,',
    introText: 'leider mussten wir feststellen, dass Sie auch auf unsere 1. Mahnung nicht reagiert haben. Der nachstehend aufgeführte Betrag ist weiterhin offen.',
    mainText: 'Wir fordern Sie hiermit letztmalig auf, den Gesamtbetrag einschließlich Mahngebühren und Verzugszinsen bis zum {paymentDeadline} zu begleichen. Sollte bis dahin kein Zahlungseingang erfolgen, werden wir ohne weitere Ankündigung rechtliche Schritte einleiten.',
    closingText: 'Dies würde für Sie weitere erhebliche Kosten bedeuten. Wir empfehlen Ihnen daher dringend, die Zahlung fristgerecht vorzunehmen.',
    signature: 'Mit freundlichen Grüßen',
  },
];

const DEFAULT_NOTICES: DunningNotice[] = [
  {
    id: 'dun-1',
    openItemId: 'oi-1',
    invoiceNumber: 'RE-2024-001',
    contactName: 'Musterfirma GmbH',
    contactAddress: 'Hauptstraße 10, 10115 Berlin',
    level: 1,
    status: 'sent',
    originalAmount: 5950,
    remainingAmount: 5950,
    dunningFee: 0,
    interestAmount: 0,
    totalAmount: 5950,
    dueDate: '2024-02-14',
    paymentDeadline: '2024-03-01',
    sentDate: '2024-02-20',
    sentVia: 'email',
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
  },
];

export function useDunning() {
  const [notices, setNotices] = useState<DunningNotice[]>([]);
  const [settings, setSettings] = useState<DunningSettings>(DEFAULT_SETTINGS);
  const [templates, setTemplates] = useState<DunningTemplate[]>(DEFAULT_TEMPLATES);
  const [isLoading, setIsLoading] = useState(true);

  // Load from localStorage
  useEffect(() => {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      try {
        const data = JSON.parse(stored);
        setNotices(data.notices || DEFAULT_NOTICES);
        setSettings(data.settings || DEFAULT_SETTINGS);
        setTemplates(data.templates || DEFAULT_TEMPLATES);
      } catch {
        setNotices(DEFAULT_NOTICES);
      }
    } else {
      setNotices(DEFAULT_NOTICES);
    }
    setIsLoading(false);
  }, []);

  // Save to localStorage
  const saveData = useCallback((
    newNotices?: DunningNotice[],
    newSettings?: DunningSettings,
    newTemplates?: DunningTemplate[]
  ) => {
    const data = {
      notices: newNotices || notices,
      settings: newSettings || settings,
      templates: newTemplates || templates,
    };
    if (newNotices) setNotices(newNotices);
    if (newSettings) setSettings(newSettings);
    if (newTemplates) setTemplates(newTemplates);
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }, [notices, settings, templates]);

  // Update settings
  const updateSettings = useCallback((updates: Partial<DunningSettings>) => {
    saveData(undefined, { ...settings, ...updates });
  }, [settings, saveData]);

  // Update template
  const updateTemplate = useCallback((level: DunningLevel, updates: Partial<DunningTemplate>) => {
    const newTemplates = templates.map(t =>
      t.level === level ? { ...t, ...updates } : t
    );
    saveData(undefined, undefined, newTemplates);
  }, [templates, saveData]);

  // Calculate interest
  const calculateInterest = useCallback((amount: number, daysOverdue: number, rate: number): number => {
    // Annual rate to daily rate, then calculate for days overdue
    const dailyRate = rate / 100 / 365;
    return Math.round(amount * dailyRate * daysOverdue * 100) / 100;
  }, []);

  // Determine dunning level based on days overdue
  const determineDunningLevel = useCallback((daysOverdue: number): DunningLevel => {
    if (daysOverdue >= settings.level3DaysOverdue) return 3;
    if (daysOverdue >= settings.level2DaysOverdue) return 2;
    if (daysOverdue >= settings.level1DaysOverdue) return 1;
    return 0;
  }, [settings]);

  // Get fee for level
  const getFeeForLevel = useCallback((level: DunningLevel): number => {
    switch (level) {
      case 1: return settings.level1Fee;
      case 2: return settings.level2Fee;
      case 3: return settings.level3Fee;
      default: return 0;
    }
  }, [settings]);

  // Get interest rate for level
  const getInterestRateForLevel = useCallback((level: DunningLevel): number => {
    switch (level) {
      case 1: return settings.level1InterestRate;
      case 2: return settings.level2InterestRate;
      case 3: return settings.level3InterestRate;
      default: return 0;
    }
  }, [settings]);

  // Create dunning notice
  const createNotice = useCallback((data: {
    openItemId: string;
    invoiceNumber: string;
    contactId?: string;
    contactName: string;
    contactAddress: string;
    originalAmount: number;
    remainingAmount: number;
    dueDate: string;
    currentDunningLevel?: number;
  }): DunningNotice | null => {
    const today = new Date();
    const dueDate = new Date(data.dueDate);
    const daysOverdue = Math.floor((today.getTime() - dueDate.getTime()) / (1000 * 60 * 60 * 24));

    if (daysOverdue < settings.level1DaysOverdue) {
      return null; // Not yet due for dunning
    }

    const nextLevel = Math.min((data.currentDunningLevel || 0) + 1, 3) as DunningLevel;
    const fee = getFeeForLevel(nextLevel);
    const interestRate = getInterestRateForLevel(nextLevel);
    const interest = calculateInterest(data.remainingAmount, daysOverdue, interestRate);

    const paymentDeadline = new Date(today);
    paymentDeadline.setDate(paymentDeadline.getDate() + settings.paymentDeadlineDays);

    const notice: DunningNotice = {
      id: `dun-${Date.now()}`,
      openItemId: data.openItemId,
      invoiceNumber: data.invoiceNumber,
      contactId: data.contactId,
      contactName: data.contactName,
      contactAddress: data.contactAddress,
      level: nextLevel,
      status: 'draft',
      originalAmount: data.originalAmount,
      remainingAmount: data.remainingAmount,
      dunningFee: fee,
      interestAmount: interest,
      totalAmount: data.remainingAmount + fee + interest,
      dueDate: data.dueDate,
      paymentDeadline: paymentDeadline.toISOString().split('T')[0],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    saveData([...notices, notice]);
    return notice;
  }, [notices, settings, calculateInterest, getFeeForLevel, getInterestRateForLevel, saveData]);

  // Update notice
  const updateNotice = useCallback((id: string, updates: Partial<DunningNotice>) => {
    saveData(notices.map(n =>
      n.id === id ? { ...n, ...updates, updatedAt: new Date().toISOString() } : n
    ));
  }, [notices, saveData]);

  // Delete notice
  const deleteNotice = useCallback((id: string) => {
    saveData(notices.filter(n => n.id !== id));
  }, [notices, saveData]);

  // Mark as sent
  const markAsSent = useCallback((id: string, via: 'email' | 'mail' | 'fax') => {
    updateNotice(id, {
      status: 'sent',
      sentDate: new Date().toISOString().split('T')[0],
      sentVia: via,
    });
  }, [updateNotice]);

  // Mark as paid
  const markAsPaid = useCallback((id: string) => {
    updateNotice(id, { status: 'paid' });
  }, [updateNotice]);

  // Cancel notice
  const cancelNotice = useCallback((id: string) => {
    updateNotice(id, { status: 'cancelled' });
  }, [updateNotice]);

  // Generate dunning text
  const generateDunningText = useCallback((notice: DunningNotice): string => {
    const template = templates.find(t => t.level === notice.level);
    if (!template) return '';

    const replacements: Record<string, string> = {
      '{invoiceNumber}': notice.invoiceNumber,
      '{contactName}': notice.contactName,
      '{originalAmount}': notice.originalAmount.toFixed(2).replace('.', ',') + ' €',
      '{remainingAmount}': notice.remainingAmount.toFixed(2).replace('.', ',') + ' €',
      '{dunningFee}': notice.dunningFee.toFixed(2).replace('.', ',') + ' €',
      '{interestAmount}': notice.interestAmount.toFixed(2).replace('.', ',') + ' €',
      '{totalAmount}': notice.totalAmount.toFixed(2).replace('.', ',') + ' €',
      '{dueDate}': new Date(notice.dueDate).toLocaleDateString('de-DE'),
      '{paymentDeadline}': new Date(notice.paymentDeadline).toLocaleDateString('de-DE'),
      '{today}': new Date().toLocaleDateString('de-DE'),
      '{companyName}': settings.companyName,
      '{bankDetails}': settings.bankDetails,
    };

    let text = `${template.subject}\n\n`;
    text += `${template.salutation}\n\n`;
    text += `${template.introText}\n\n`;
    text += `Rechnungsnummer: ${notice.invoiceNumber}\n`;
    text += `Rechnungsbetrag: ${replacements['{originalAmount}']}\n`;
    text += `Offener Betrag: ${replacements['{remainingAmount}']}\n`;
    if (notice.dunningFee > 0) text += `Mahngebühr: ${replacements['{dunningFee}']}\n`;
    if (notice.interestAmount > 0) text += `Verzugszinsen: ${replacements['{interestAmount}']}\n`;
    text += `Gesamtbetrag: ${replacements['{totalAmount}']}\n\n`;
    text += `${template.mainText}\n\n`;
    text += `${template.closingText}\n\n`;
    text += `${template.signature}\n`;
    text += `${settings.companyName}\n\n`;
    text += `Bankverbindung: ${settings.bankDetails}`;

    // Replace all placeholders
    Object.entries(replacements).forEach(([key, value]) => {
      text = text.replace(new RegExp(key.replace(/[{}]/g, '\\$&'), 'g'), value);
    });

    return text;
  }, [templates, settings]);

  // Get notices by status
  const getByStatus = useCallback((status: DunningStatus): DunningNotice[] => {
    return notices.filter(n => n.status === status);
  }, [notices]);

  // Get notices for open item
  const getForOpenItem = useCallback((openItemId: string): DunningNotice[] => {
    return notices
      .filter(n => n.openItemId === openItemId)
      .sort((a, b) => b.level - a.level);
  }, [notices]);

  // Get summary
  const getSummary = useCallback(() => {
    const draft = notices.filter(n => n.status === 'draft');
    const sent = notices.filter(n => n.status === 'sent');
    const level1 = notices.filter(n => n.level === 1 && n.status !== 'paid' && n.status !== 'cancelled');
    const level2 = notices.filter(n => n.level === 2 && n.status !== 'paid' && n.status !== 'cancelled');
    const level3 = notices.filter(n => n.level === 3 && n.status !== 'paid' && n.status !== 'cancelled');

    const totalOutstanding = sent.reduce((sum, n) => sum + n.totalAmount, 0);
    const totalFees = notices
      .filter(n => n.status !== 'cancelled')
      .reduce((sum, n) => sum + n.dunningFee, 0);
    const totalInterest = notices
      .filter(n => n.status !== 'cancelled')
      .reduce((sum, n) => sum + n.interestAmount, 0);

    return {
      totalNotices: notices.length,
      draftCount: draft.length,
      sentCount: sent.length,
      level1Count: level1.length,
      level2Count: level2.length,
      level3Count: level3.length,
      totalOutstanding,
      totalFees,
      totalInterest,
    };
  }, [notices]);

  // Export notices
  const exportNotices = useCallback(() => {
    const headers = ['Mahnstufe', 'Rechnungsnr.', 'Kontakt', 'Status', 'Offener Betrag', 'Mahngebühr', 'Zinsen', 'Gesamt', 'Frist'];
    const rows = notices.map(n => [
      n.level.toString(),
      n.invoiceNumber,
      n.contactName,
      n.status,
      n.remainingAmount.toFixed(2),
      n.dunningFee.toFixed(2),
      n.interestAmount.toFixed(2),
      n.totalAmount.toFixed(2),
      n.paymentDeadline,
    ]);
    const csv = [headers.join(';'), ...rows.map(r => r.join(';'))].join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `mahnungen_${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }, [notices]);

  return {
    notices,
    settings,
    templates,
    isLoading,
    updateSettings,
    updateTemplate,
    createNotice,
    updateNotice,
    deleteNotice,
    markAsSent,
    markAsPaid,
    cancelNotice,
    generateDunningText,
    getByStatus,
    getForOpenItem,
    getSummary,
    exportNotices,
    determineDunningLevel,
    calculateInterest,
  };
}
